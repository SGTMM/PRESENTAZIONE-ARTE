{"mappings":"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","sources":["<anon>","src/sketch.js"],"sourcesContent":["let StickStatus = {\n    xPosition: 0,\n    yPosition: 0,\n    x: 0,\n    y: 0,\n    cardinalDirection: \"C\"\n};\n/**\r\n * @desc Principal object that draw a joystick, you only need to initialize the object and suggest the HTML container\r\n * @costructor\r\n * @param container {String} - HTML object that contains the Joystick\r\n * @param parameters (optional) - object with following keys:\r\n *  title {String} (optional) - The ID of canvas (Default value is 'joystick')\r\n *  width {Int} (optional) - The width of canvas, if not specified is setted at width of container object (Default value is the width of container object)\r\n *  height {Int} (optional) - The height of canvas, if not specified is setted at height of container object (Default value is the height of container object)\r\n *  internalFillColor {String} (optional) - Internal color of Stick (Default value is '#00AA00')\r\n *  internalLineWidth {Int} (optional) - Border width of Stick (Default value is 2)\r\n *  internalStrokeColor {String}(optional) - Border color of Stick (Default value is '#003300')\r\n *  externalLineWidth {Int} (optional) - External reference circonference width (Default value is 2)\r\n *  externalStrokeColor {String} (optional) - External reference circonference color (Default value is '#008000')\r\n *  autoReturnToCenter {Bool} (optional) - Sets the behavior of the stick, whether or not, it should return to zero position when released (Default value is True and return to zero)\r\n * @param callback {StickStatus} - \r\n */ var JoyStick = function(container, parameters, callback) {\n    parameters = parameters || {};\n    var title = typeof parameters.title === \"undefined\" ? \"joystick\" : parameters.title, width = typeof parameters.width === \"undefined\" ? 0 : parameters.width, height = typeof parameters.height === \"undefined\" ? 0 : parameters.height, internalFillColor = typeof parameters.internalFillColor === \"undefined\" ? \"#00AA00\" : parameters.internalFillColor, internalLineWidth = typeof parameters.internalLineWidth === \"undefined\" ? 2 : parameters.internalLineWidth, internalStrokeColor = typeof parameters.internalStrokeColor === \"undefined\" ? \"#003300\" : parameters.internalStrokeColor, externalLineWidth = typeof parameters.externalLineWidth === \"undefined\" ? 2 : parameters.externalLineWidth, externalStrokeColor = typeof parameters.externalStrokeColor === \"undefined\" ? \"#008000\" : parameters.externalStrokeColor, autoReturnToCenter = typeof parameters.autoReturnToCenter === \"undefined\" ? true : parameters.autoReturnToCenter;\n    callback = callback || function(StickStatus) {};\n    // Create Canvas element and add it in the Container object\n    var objContainer = document.getElementById(container);\n    // Fixing Unable to preventDefault inside passive event listener due to target being treated as passive in Chrome [Thanks to https://github.com/artisticfox8 for this suggestion]\n    objContainer.style.touchAction = \"none\";\n    var canvas = document.createElement(\"canvas\");\n    canvas.id = title;\n    if (width === 0) width = objContainer.clientWidth;\n    if (height === 0) height = objContainer.clientHeight;\n    canvas.width = width;\n    canvas.height = height;\n    objContainer.appendChild(canvas);\n    var context = canvas.getContext(\"2d\");\n    var pressed = 0; // Bool - 1=Yes - 0=No\n    var circumference = 2 * Math.PI;\n    var internalRadius = (canvas.width - (canvas.width / 2 + 10)) / 2;\n    var maxMoveStick = internalRadius + 5;\n    var externalRadius = internalRadius + 30;\n    var centerX = canvas.width / 2;\n    var centerY = canvas.height / 2;\n    var directionHorizontalLimitPos = canvas.width / 10;\n    var directionHorizontalLimitNeg = directionHorizontalLimitPos * -1;\n    var directionVerticalLimitPos = canvas.height / 10;\n    var directionVerticalLimitNeg = directionVerticalLimitPos * -1;\n    // Used to save current position of stick\n    var movedX = centerX;\n    var movedY = centerY;\n    // Check if the device support the touch or not\n    if (\"ontouchstart\" in document.documentElement) {\n        canvas.addEventListener(\"touchstart\", onTouchStart, false);\n        document.addEventListener(\"touchmove\", onTouchMove, false);\n        document.addEventListener(\"touchend\", onTouchEnd, false);\n    } else {\n        canvas.addEventListener(\"mousedown\", onMouseDown, false);\n        document.addEventListener(\"mousemove\", onMouseMove, false);\n        document.addEventListener(\"mouseup\", onMouseUp, false);\n    }\n    // Draw the object\n    drawExternal();\n    drawInternal();\n    /******************************************************\r\n     * Private methods\r\n     *****************************************************/ /**\r\n     * @desc Draw the external circle used as reference position\r\n     */ function drawExternal() {\n        context.beginPath();\n        context.arc(centerX, centerY, externalRadius, 0, circumference, false);\n        context.lineWidth = externalLineWidth;\n        context.strokeStyle = externalStrokeColor;\n        context.stroke();\n    }\n    /**\r\n     * @desc Draw the internal stick in the current position the user have moved it\r\n     */ function drawInternal() {\n        context.beginPath();\n        if (movedX < internalRadius) movedX = maxMoveStick;\n        if (movedX + internalRadius > canvas.width) movedX = canvas.width - maxMoveStick;\n        if (movedY < internalRadius) movedY = maxMoveStick;\n        if (movedY + internalRadius > canvas.height) movedY = canvas.height - maxMoveStick;\n        context.arc(movedX, movedY, internalRadius, 0, circumference, false);\n        // create radial gradient\n        var grd = context.createRadialGradient(centerX, centerY, 5, centerX, centerY, 200);\n        // Light color\n        grd.addColorStop(0, internalFillColor);\n        // Dark color\n        grd.addColorStop(1, internalStrokeColor);\n        context.fillStyle = grd;\n        context.fill();\n        context.lineWidth = internalLineWidth;\n        context.strokeStyle = internalStrokeColor;\n        context.stroke();\n    }\n    /**\r\n     * @desc Events for manage touch\r\n     */ function onTouchStart(event) {\n        pressed = 1;\n    }\n    function onTouchMove(event) {\n        if (pressed === 1 && event.targetTouches[0].target === canvas) {\n            movedX = event.targetTouches[0].pageX;\n            movedY = event.targetTouches[0].pageY;\n            // Manage offset\n            if (canvas.offsetParent.tagName.toUpperCase() === \"BODY\") {\n                movedX -= canvas.offsetLeft;\n                movedY -= canvas.offsetTop;\n            } else {\n                movedX -= canvas.offsetParent.offsetLeft;\n                movedY -= canvas.offsetParent.offsetTop;\n            }\n            // Delete canvas\n            context.clearRect(0, 0, canvas.width, canvas.height);\n            // Redraw object\n            drawExternal();\n            drawInternal();\n            // Set attribute of callback\n            StickStatus.xPosition = movedX;\n            StickStatus.yPosition = movedY;\n            StickStatus.x = (100 * ((movedX - centerX) / maxMoveStick)).toFixed();\n            StickStatus.y = (100 * ((movedY - centerY) / maxMoveStick) * -1).toFixed();\n            StickStatus.cardinalDirection = getCardinalDirection();\n            callback(StickStatus);\n        }\n    }\n    function onTouchEnd(event) {\n        pressed = 0;\n        // If required reset position store variable\n        if (autoReturnToCenter) {\n            movedX = centerX;\n            movedY = centerY;\n        }\n        // Delete canvas\n        context.clearRect(0, 0, canvas.width, canvas.height);\n        // Redraw object\n        drawExternal();\n        drawInternal();\n        // Set attribute of callback\n        StickStatus.xPosition = movedX;\n        StickStatus.yPosition = movedY;\n        StickStatus.x = (100 * ((movedX - centerX) / maxMoveStick)).toFixed();\n        StickStatus.y = (100 * ((movedY - centerY) / maxMoveStick) * -1).toFixed();\n        StickStatus.cardinalDirection = getCardinalDirection();\n        callback(StickStatus);\n    }\n    /**\r\n     * @desc Events for manage mouse\r\n     */ function onMouseDown(event) {\n        pressed = 1;\n    }\n    /* To simplify this code there was a new experimental feature here: https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/offsetX , but it present only in Mouse case not metod presents in Touch case :-( */ function onMouseMove(event) {\n        if (pressed === 1) {\n            movedX = event.pageX;\n            movedY = event.pageY;\n            // Manage offset\n            if (canvas.offsetParent.tagName.toUpperCase() === \"BODY\") {\n                movedX -= canvas.offsetLeft;\n                movedY -= canvas.offsetTop;\n            } else {\n                movedX -= canvas.offsetParent.offsetLeft;\n                movedY -= canvas.offsetParent.offsetTop;\n            }\n            // Delete canvas\n            context.clearRect(0, 0, canvas.width, canvas.height);\n            // Redraw object\n            drawExternal();\n            drawInternal();\n            // Set attribute of callback\n            StickStatus.xPosition = movedX;\n            StickStatus.yPosition = movedY;\n            StickStatus.x = (100 * ((movedX - centerX) / maxMoveStick)).toFixed();\n            StickStatus.y = (100 * ((movedY - centerY) / maxMoveStick) * -1).toFixed();\n            StickStatus.cardinalDirection = getCardinalDirection();\n            callback(StickStatus);\n        }\n    }\n    function onMouseUp(event) {\n        pressed = 0;\n        // If required reset position store variable\n        if (autoReturnToCenter) {\n            movedX = centerX;\n            movedY = centerY;\n        }\n        // Delete canvas\n        context.clearRect(0, 0, canvas.width, canvas.height);\n        // Redraw object\n        drawExternal();\n        drawInternal();\n        // Set attribute of callback\n        StickStatus.xPosition = movedX;\n        StickStatus.yPosition = movedY;\n        StickStatus.x = (100 * ((movedX - centerX) / maxMoveStick)).toFixed();\n        StickStatus.y = (100 * ((movedY - centerY) / maxMoveStick) * -1).toFixed();\n        StickStatus.cardinalDirection = getCardinalDirection();\n        callback(StickStatus);\n    }\n    function getCardinalDirection() {\n        let result = \"\";\n        let orizontal = movedX - centerX;\n        let vertical = movedY - centerY;\n        if (vertical >= directionVerticalLimitNeg && vertical <= directionVerticalLimitPos) result = \"C\";\n        if (vertical < directionVerticalLimitNeg) result = \"N\";\n        if (vertical > directionVerticalLimitPos) result = \"S\";\n        if (orizontal < directionHorizontalLimitNeg) {\n            if (result === \"C\") result = \"W\";\n            else result += \"W\";\n        }\n        if (orizontal > directionHorizontalLimitPos) {\n            if (result === \"C\") result = \"E\";\n            else result += \"E\";\n        }\n        return result;\n    }\n    /******************************************************\r\n     * Public methods\r\n     *****************************************************/ /**\r\n     * @desc The width of canvas\r\n     * @return Number of pixel width \r\n     */ this.GetWidth = function() {\n        return canvas.width;\n    };\n    /**\r\n     * @desc The height of canvas\r\n     * @return Number of pixel height\r\n     */ this.GetHeight = function() {\n        return canvas.height;\n    };\n    /**\r\n     * @desc The X position of the cursor relative to the canvas that contains it and to its dimensions\r\n     * @return Number that indicate relative position\r\n     */ this.GetPosX = function() {\n        return movedX;\n    };\n    /**\r\n     * @desc The Y position of the cursor relative to the canvas that contains it and to its dimensions\r\n     * @return Number that indicate relative position\r\n     */ this.GetPosY = function() {\n        return movedY;\n    };\n    /**\r\n     * @desc Normalizzed value of X move of stick\r\n     * @return Integer from -100 to +100\r\n     */ this.GetX = function() {\n        return (100 * ((movedX - centerX) / maxMoveStick)).toFixed();\n    };\n    /**\r\n     * @desc Normalizzed value of Y move of stick\r\n     * @return Integer from -100 to +100\r\n     */ this.GetY = function() {\n        return (100 * ((movedY - centerY) / maxMoveStick) * -1).toFixed();\n    };\n    /**\r\n     * @desc Get the direction of the cursor as a string that indicates the cardinal points where this is oriented\r\n     * @return String of cardinal point N, NE, E, SE, S, SW, W, NW and C when it is placed in the center\r\n     */ this.GetDir = function() {\n        return getCardinalDirection();\n    };\n};\nvar moveDirection = {\n    left: 0,\n    right: 0,\n    forward: 0,\n    back: 0\n};\nvar ground;\nvar player;\nvar clock;\nvar prev_pos;\nvar rotateQuat, walkDir, directionOffset;\nvar delta;\nvar player_collider;\nvar correctedVector;\nvar moveX = 0;\nvar moveZ = 0;\nvar dir;\nvar forward_vector;\nvar model_ready = false;\nvar mouseDown;\nvar aimDown;\nvar camDir;\nvar mov_vector;\nvar model;\nvar scene, renderer, camera, controls;\nvar toggle = false;\nvar box;\nwindow.addEventListener(\"load\", function() {\n    setTimeout(()=>{\n        load_model();\n    }, 3000);\n});\nvar joy = new JoyStick(\"joyDiv\", {\n    // The ID of canvas element\n    title: \"joystick\",\n    // Internal color of Stick\n    internalFillColor: \"#00AA00\",\n    // Border width of Stick\n    internalLineWidth: 2,\n    // Border color of Stick\n    internalStrokeColor: \"#003300\",\n    // External reference circonference width\n    externalLineWidth: 2,\n    //External reference circonference color\n    externalStrokeColor: \"#008000\",\n    // Sets the behavior of the stick\n    autoReturnToCenter: true\n});\nfunction load_model() {\n    new GLTFLoader().load(\"scene (7).glb\", function(gltf) {\n        model = gltf.scene;\n        console.log(model);\n        toggle = true;\n        wait_models();\n    });\n}\nfunction wait_models() {\n    if (toggle) {\n        setupEventHandlers();\n        scene = new THREE.Scene();\n        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);\n        camera.updateProjectionMatrix();\n        camera.position.y += 7;\n        renderer = new THREE.WebGLRenderer({\n            antialias: true,\n            alpha: true\n        });\n        renderer.setSize(window.innerWidth, window.innerHeight);\n        controls = new OrbitControls(camera, renderer.domElement);\n        window.addEventListener(\"resize\", function() {\n            camera.aspect = window.innerWidth / window.innerHeight;\n            camera.updateProjectionMatrix();\n            renderer.setSize(window.innerWidth, window.innerHeight);\n        });\n        document.body.appendChild(renderer.domElement);\n        clock = new THREE.Clock();\n        mov_vector = new THREE.Vector3();\n        camDir = new THREE.Vector3();\n        prev_pos = new THREE.Vector3();\n        var ambientLight = new THREE.AmbientLight(0xffffff, 5);\n        scene.add(ambientLight);\n        scene.add(model);\n        const geometry = new THREE.BoxGeometry(0.2, 0.2, 0.2);\n        const material = new THREE.MeshBasicMaterial({\n            color: 0x00ff00\n        });\n        box = new THREE.Mesh(geometry, material);\n        scene.add(box);\n        box.position.y = 7;\n        //box.position.z = -1\n        update();\n    }\n}\nvar prev_x = 0;\nvar prev_z = 0;\nvar x = 0;\nvar z = 0;\nfunction update() {\n    delta = clock.getDelta();\n    camera.getWorldDirection(camDir);\n    //console.log(camDir)\n    moveZ = moveDirection.right - moveDirection.left;\n    moveX = moveDirection.forward - moveDirection.back;\n    mov_vector.x = camDir.x / 2.5;\n    mov_vector.z = camDir.z / 2.5;\n    directionOffset = 0;\n    if (moveX === 1) {\n        if (moveZ === 1) directionOffset = -Math.PI / 4;\n        else if (moveZ === -1) directionOffset = Math.PI / 4;\n    } else if (moveX === -1) {\n        if (moveZ === 1) directionOffset = -Math.PI / 4 - Math.PI / 2;\n        else if (moveZ === -1) directionOffset = Math.PI / 4 + Math.PI / 2;\n        else directionOffset = Math.PI;\n    } else if (moveZ === 1) directionOffset = -Math.PI / 2;\n    else if (moveZ === -1) directionOffset = Math.PI / 2;\n    mov_vector.applyAxisAngle(new THREE.Vector3(0, 1, 0), directionOffset);\n    if (moveX !== 0 || moveZ !== 0) {\n        camera.position.x += mov_vector.x;\n        camera.position.z += mov_vector.z;\n        box.position.x += mov_vector.x;\n        box.position.z += mov_vector.z;\n    }\n    controls.target.copy(box.position);\n    x = parseInt(joy.GetX());\n    z = parseInt(joy.GetY());\n    if (x >= 75) {\n        moveDirection.right = 1;\n        moveDirection.left = 0;\n    } else if (x <= -75) {\n        moveDirection.right = 0;\n        moveDirection.left = 1;\n    } else {\n        moveDirection.right = 0;\n        moveDirection.left = 0;\n    }\n    if (z >= 75) {\n        moveDirection.forward = 1;\n        moveDirection.back = 0;\n    } else if (z <= -75) {\n        moveDirection.forward = 0;\n        moveDirection.back = 1;\n    } else {\n        moveDirection.forward = 0;\n        moveDirection.back = 0;\n    }\n    if (isPointInsideBox(camera.position.x, camera.position.z)) {\n        prev_x = camera.position.x;\n        prev_z = camera.position.z;\n        prev_pos.x = box.position.x;\n        prev_pos.z = box.position.z;\n    } else {\n        camera.position.x = prev_x;\n        camera.position.z = prev_z;\n        box.position.x = prev_pos.x;\n        box.position.z = prev_pos.z;\n    }\n    controls.update();\n    renderer.render(scene, camera);\n    requestAnimationFrame(update);\n}\nfunction isPointInsideBox(x, z) {\n    // Check if x and z are within the bounding box\n    const minX = Math.min(-76.21540612288777, -75.9593510912879, 202.57380081700836, 203.17769907829856);\n    const maxX = Math.max(-76.21540612288777, -75.9593510912879, 202.57380081700836, 203.17769907829856);\n    const minZ = Math.min(-8.791333228457304, 26.63528778585343, 26.531239999910195, -8.855059994891958);\n    const maxZ = Math.max(-8.791333228457304, 26.63528778585343, 26.531239999910195, -8.855059994891958);\n    if (x < minX || x > maxX || z < minZ || z > maxZ) // Point is outside the bounding box\n    return false;\n    // If x and z are within the bounding box, check if the point is inside the convex hull of the vertices\n    const insideConvexHull = isPointInsideConvexHull(x, z);\n    return insideConvexHull;\n}\n// Helper function to check if a point is inside the convex hull of the box vertices\nfunction isPointInsideConvexHull(x, z) {\n    // Implement your convex hull check algorithm here.\n    // This could be done using techniques like the winding number algorithm.\n    // For simplicity, let's assume the vertices form a convex quadrilateral.\n    // You may need to replace this part with a more robust algorithm for complex polygons.\n    // In this example, we assume the vertices are in counter-clockwise order.\n    const AB = 0.2560550315998711 * (z - -8.791333228457304) - (x - -76.21540612288777) * 35.42662101431073;\n    const BC = 278.53315190829625 * (z - 26.63528778585343) - (x - -75.9593510912879) * -0.1040477859432336;\n    const CD = 0.6038982612901975 * (z - 26.531239999910195) - (x - 202.57380081700836) * -35.38629999480215;\n    const DA = -279.39310520118636 * (z - -8.855059994891958) - (x - 203.17769907829856) * 0.06372676643465347;\n    return AB >= 0 && BC >= 0 && CD >= 0 && DA >= 0 || AB <= 0 && BC <= 0 && CD <= 0 && DA <= 0;\n}\nfunction handleKeyDown(event) {\n    let keyCode = event.keyCode;\n    //console.log(keyCode)\n    switch(keyCode){\n        case 87:\n            moveDirection.forward = 1;\n            break;\n        case 83:\n            moveDirection.back = 1;\n            break;\n        case 65:\n            moveDirection.left = 1;\n            break;\n        case 68:\n            moveDirection.right = 1;\n            break;\n    }\n}\nfunction handleKeyUp(event) {\n    let keyCode = event.keyCode;\n    switch(keyCode){\n        case 87:\n            moveDirection.forward = 0;\n            break;\n        case 83:\n            moveDirection.back = 0;\n            break;\n        case 65:\n            moveDirection.left = 0;\n            break;\n        case 68:\n            moveDirection.right = 0;\n            break;\n    }\n}\nfunction windowResized() {\n    resizeCanvas3D(windowWidth, windowHeight);\n}\nfunction setupEventHandlers() {\n    window.addEventListener(\"keydown\", handleKeyDown, false);\n    window.addEventListener(\"keyup\", handleKeyUp, false);\n}\n\n//# sourceMappingURL=index.1a49ce9c.js.map\n","let StickStatus =\r\n{\r\n    xPosition: 0,\r\n    yPosition: 0,\r\n    x: 0,\r\n    y: 0,\r\n    cardinalDirection: \"C\"\r\n};\r\n\r\n/**\r\n * @desc Principal object that draw a joystick, you only need to initialize the object and suggest the HTML container\r\n * @costructor\r\n * @param container {String} - HTML object that contains the Joystick\r\n * @param parameters (optional) - object with following keys:\r\n *  title {String} (optional) - The ID of canvas (Default value is 'joystick')\r\n *  width {Int} (optional) - The width of canvas, if not specified is setted at width of container object (Default value is the width of container object)\r\n *  height {Int} (optional) - The height of canvas, if not specified is setted at height of container object (Default value is the height of container object)\r\n *  internalFillColor {String} (optional) - Internal color of Stick (Default value is '#00AA00')\r\n *  internalLineWidth {Int} (optional) - Border width of Stick (Default value is 2)\r\n *  internalStrokeColor {String}(optional) - Border color of Stick (Default value is '#003300')\r\n *  externalLineWidth {Int} (optional) - External reference circonference width (Default value is 2)\r\n *  externalStrokeColor {String} (optional) - External reference circonference color (Default value is '#008000')\r\n *  autoReturnToCenter {Bool} (optional) - Sets the behavior of the stick, whether or not, it should return to zero position when released (Default value is True and return to zero)\r\n * @param callback {StickStatus} - \r\n */\r\nvar JoyStick = (function(container, parameters, callback)\r\n{\r\n    parameters = parameters || {};\r\n    var title = (typeof parameters.title === \"undefined\" ? \"joystick\" : parameters.title),\r\n        width = (typeof parameters.width === \"undefined\" ? 0 : parameters.width),\r\n        height = (typeof parameters.height === \"undefined\" ? 0 : parameters.height),\r\n        internalFillColor = (typeof parameters.internalFillColor === \"undefined\" ? \"#00AA00\" : parameters.internalFillColor),\r\n        internalLineWidth = (typeof parameters.internalLineWidth === \"undefined\" ? 2 : parameters.internalLineWidth),\r\n        internalStrokeColor = (typeof parameters.internalStrokeColor === \"undefined\" ? \"#003300\" : parameters.internalStrokeColor),\r\n        externalLineWidth = (typeof parameters.externalLineWidth === \"undefined\" ? 2 : parameters.externalLineWidth),\r\n        externalStrokeColor = (typeof parameters.externalStrokeColor ===  \"undefined\" ? \"#008000\" : parameters.externalStrokeColor),\r\n        autoReturnToCenter = (typeof parameters.autoReturnToCenter === \"undefined\" ? true : parameters.autoReturnToCenter);\r\n\r\n    callback = callback || function(StickStatus) {};\r\n\r\n    // Create Canvas element and add it in the Container object\r\n    var objContainer = document.getElementById(container);\r\n    \r\n    // Fixing Unable to preventDefault inside passive event listener due to target being treated as passive in Chrome [Thanks to https://github.com/artisticfox8 for this suggestion]\r\n    objContainer.style.touchAction = \"none\";\r\n\r\n    var canvas = document.createElement(\"canvas\");\r\n    canvas.id = title;\r\n    if(width === 0) { width = objContainer.clientWidth; }\r\n    if(height === 0) { height = objContainer.clientHeight; }\r\n    canvas.width = width;\r\n    canvas.height = height;\r\n    objContainer.appendChild(canvas);\r\n    var context=canvas.getContext(\"2d\");\r\n\r\n    var pressed = 0; // Bool - 1=Yes - 0=No\r\n    var circumference = 2 * Math.PI;\r\n    var internalRadius = (canvas.width-((canvas.width/2)+10))/2;\r\n    var maxMoveStick = internalRadius + 5;\r\n    var externalRadius = internalRadius + 30;\r\n    var centerX = canvas.width / 2;\r\n    var centerY = canvas.height / 2;\r\n    var directionHorizontalLimitPos = canvas.width / 10;\r\n    var directionHorizontalLimitNeg = directionHorizontalLimitPos * -1;\r\n    var directionVerticalLimitPos = canvas.height / 10;\r\n    var directionVerticalLimitNeg = directionVerticalLimitPos * -1;\r\n    // Used to save current position of stick\r\n    var movedX=centerX;\r\n    var movedY=centerY;\r\n\r\n    // Check if the device support the touch or not\r\n    if(\"ontouchstart\" in document.documentElement)\r\n    {\r\n        canvas.addEventListener(\"touchstart\", onTouchStart, false);\r\n        document.addEventListener(\"touchmove\", onTouchMove, false);\r\n        document.addEventListener(\"touchend\", onTouchEnd, false);\r\n    }\r\n    else\r\n    {\r\n        canvas.addEventListener(\"mousedown\", onMouseDown, false);\r\n        document.addEventListener(\"mousemove\", onMouseMove, false);\r\n        document.addEventListener(\"mouseup\", onMouseUp, false);\r\n    }\r\n    // Draw the object\r\n    drawExternal();\r\n    drawInternal();\r\n\r\n    /******************************************************\r\n     * Private methods\r\n     *****************************************************/\r\n\r\n    /**\r\n     * @desc Draw the external circle used as reference position\r\n     */\r\n    function drawExternal()\r\n    {\r\n        context.beginPath();\r\n        context.arc(centerX, centerY, externalRadius, 0, circumference, false);\r\n        context.lineWidth = externalLineWidth;\r\n        context.strokeStyle = externalStrokeColor;\r\n        context.stroke();\r\n    }\r\n\r\n    /**\r\n     * @desc Draw the internal stick in the current position the user have moved it\r\n     */\r\n    function drawInternal()\r\n    {\r\n        context.beginPath();\r\n        if(movedX<internalRadius) { movedX=maxMoveStick; }\r\n        if((movedX+internalRadius) > canvas.width) { movedX = canvas.width-(maxMoveStick); }\r\n        if(movedY<internalRadius) { movedY=maxMoveStick; }\r\n        if((movedY+internalRadius) > canvas.height) { movedY = canvas.height-(maxMoveStick); }\r\n        context.arc(movedX, movedY, internalRadius, 0, circumference, false);\r\n        // create radial gradient\r\n        var grd = context.createRadialGradient(centerX, centerY, 5, centerX, centerY, 200);\r\n        // Light color\r\n        grd.addColorStop(0, internalFillColor);\r\n        // Dark color\r\n        grd.addColorStop(1, internalStrokeColor);\r\n        context.fillStyle = grd;\r\n        context.fill();\r\n        context.lineWidth = internalLineWidth;\r\n        context.strokeStyle = internalStrokeColor;\r\n        context.stroke();\r\n    }\r\n\r\n    /**\r\n     * @desc Events for manage touch\r\n     */\r\n    function onTouchStart(event) \r\n    {\r\n        pressed = 1;\r\n    }\r\n\r\n    function onTouchMove(event)\r\n    {\r\n        if(pressed === 1 && event.targetTouches[0].target === canvas)\r\n        {\r\n            movedX = event.targetTouches[0].pageX;\r\n            movedY = event.targetTouches[0].pageY;\r\n            // Manage offset\r\n            if(canvas.offsetParent.tagName.toUpperCase() === \"BODY\")\r\n            {\r\n                movedX -= canvas.offsetLeft;\r\n                movedY -= canvas.offsetTop;\r\n            }\r\n            else\r\n            {\r\n                movedX -= canvas.offsetParent.offsetLeft;\r\n                movedY -= canvas.offsetParent.offsetTop;\r\n            }\r\n            // Delete canvas\r\n            context.clearRect(0, 0, canvas.width, canvas.height);\r\n            // Redraw object\r\n            drawExternal();\r\n            drawInternal();\r\n\r\n            // Set attribute of callback\r\n            StickStatus.xPosition = movedX;\r\n            StickStatus.yPosition = movedY;\r\n            StickStatus.x = (100*((movedX - centerX)/maxMoveStick)).toFixed();\r\n            StickStatus.y = ((100*((movedY - centerY)/maxMoveStick))*-1).toFixed();\r\n            StickStatus.cardinalDirection = getCardinalDirection();\r\n            callback(StickStatus);\r\n        }\r\n    } \r\n\r\n    function onTouchEnd(event) \r\n    {\r\n        pressed = 0;\r\n        // If required reset position store variable\r\n        if(autoReturnToCenter)\r\n        {\r\n            movedX = centerX;\r\n            movedY = centerY;\r\n        }\r\n        // Delete canvas\r\n        context.clearRect(0, 0, canvas.width, canvas.height);\r\n        // Redraw object\r\n        drawExternal();\r\n        drawInternal();\r\n\r\n        // Set attribute of callback\r\n        StickStatus.xPosition = movedX;\r\n        StickStatus.yPosition = movedY;\r\n        StickStatus.x = (100*((movedX - centerX)/maxMoveStick)).toFixed();\r\n        StickStatus.y = ((100*((movedY - centerY)/maxMoveStick))*-1).toFixed();\r\n        StickStatus.cardinalDirection = getCardinalDirection();\r\n        callback(StickStatus);\r\n    }\r\n\r\n    /**\r\n     * @desc Events for manage mouse\r\n     */\r\n    function onMouseDown(event) \r\n    {\r\n        pressed = 1;\r\n    }\r\n\r\n    /* To simplify this code there was a new experimental feature here: https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/offsetX , but it present only in Mouse case not metod presents in Touch case :-( */\r\n    function onMouseMove(event) \r\n    {\r\n        if(pressed === 1)\r\n        {\r\n            movedX = event.pageX;\r\n            movedY = event.pageY;\r\n            // Manage offset\r\n            if(canvas.offsetParent.tagName.toUpperCase() === \"BODY\")\r\n            {\r\n                movedX -= canvas.offsetLeft;\r\n                movedY -= canvas.offsetTop;\r\n            }\r\n            else\r\n            {\r\n                movedX -= canvas.offsetParent.offsetLeft;\r\n                movedY -= canvas.offsetParent.offsetTop;\r\n            }\r\n            // Delete canvas\r\n            context.clearRect(0, 0, canvas.width, canvas.height);\r\n            // Redraw object\r\n            drawExternal();\r\n            drawInternal();\r\n\r\n            // Set attribute of callback\r\n            StickStatus.xPosition = movedX;\r\n            StickStatus.yPosition = movedY;\r\n            StickStatus.x = (100*((movedX - centerX)/maxMoveStick)).toFixed();\r\n            StickStatus.y = ((100*((movedY - centerY)/maxMoveStick))*-1).toFixed();\r\n            StickStatus.cardinalDirection = getCardinalDirection();\r\n            callback(StickStatus);\r\n        }\r\n    }\r\n\r\n    function onMouseUp(event) \r\n    {\r\n        pressed = 0;\r\n        // If required reset position store variable\r\n        if(autoReturnToCenter)\r\n        {\r\n            movedX = centerX;\r\n            movedY = centerY;\r\n        }\r\n        // Delete canvas\r\n        context.clearRect(0, 0, canvas.width, canvas.height);\r\n        // Redraw object\r\n        drawExternal();\r\n        drawInternal();\r\n\r\n        // Set attribute of callback\r\n        StickStatus.xPosition = movedX;\r\n        StickStatus.yPosition = movedY;\r\n        StickStatus.x = (100*((movedX - centerX)/maxMoveStick)).toFixed();\r\n        StickStatus.y = ((100*((movedY - centerY)/maxMoveStick))*-1).toFixed();\r\n        StickStatus.cardinalDirection = getCardinalDirection();\r\n        callback(StickStatus);\r\n    }\r\n\r\n    function getCardinalDirection()\r\n    {\r\n        let result = \"\";\r\n        let orizontal = movedX - centerX;\r\n        let vertical = movedY - centerY;\r\n        \r\n        if(vertical >= directionVerticalLimitNeg && vertical <= directionVerticalLimitPos)\r\n        {\r\n            result = \"C\";\r\n        }\r\n        if(vertical < directionVerticalLimitNeg)\r\n        {\r\n            result = \"N\";\r\n        }\r\n        if(vertical > directionVerticalLimitPos)\r\n        {\r\n            result = \"S\";\r\n        }\r\n        \r\n        if(orizontal < directionHorizontalLimitNeg)\r\n        {\r\n            if(result === \"C\")\r\n            { \r\n                result = \"W\";\r\n            }\r\n            else\r\n            {\r\n                result += \"W\";\r\n            }\r\n        }\r\n        if(orizontal > directionHorizontalLimitPos)\r\n        {\r\n            if(result === \"C\")\r\n            { \r\n                result = \"E\";\r\n            }\r\n            else\r\n            {\r\n                result += \"E\";\r\n            }\r\n        }\r\n        \r\n        return result;\r\n    }\r\n\r\n    /******************************************************\r\n     * Public methods\r\n     *****************************************************/\r\n\r\n    /**\r\n     * @desc The width of canvas\r\n     * @return Number of pixel width \r\n     */\r\n    this.GetWidth = function () \r\n    {\r\n        return canvas.width;\r\n    };\r\n\r\n    /**\r\n     * @desc The height of canvas\r\n     * @return Number of pixel height\r\n     */\r\n    this.GetHeight = function () \r\n    {\r\n        return canvas.height;\r\n    };\r\n\r\n    /**\r\n     * @desc The X position of the cursor relative to the canvas that contains it and to its dimensions\r\n     * @return Number that indicate relative position\r\n     */\r\n    this.GetPosX = function ()\r\n    {\r\n        return movedX;\r\n    };\r\n\r\n    /**\r\n     * @desc The Y position of the cursor relative to the canvas that contains it and to its dimensions\r\n     * @return Number that indicate relative position\r\n     */\r\n    this.GetPosY = function ()\r\n    {\r\n        return movedY;\r\n    };\r\n\r\n    /**\r\n     * @desc Normalizzed value of X move of stick\r\n     * @return Integer from -100 to +100\r\n     */\r\n    this.GetX = function ()\r\n    {\r\n        return (100*((movedX - centerX)/maxMoveStick)).toFixed();\r\n    };\r\n\r\n    /**\r\n     * @desc Normalizzed value of Y move of stick\r\n     * @return Integer from -100 to +100\r\n     */\r\n    this.GetY = function ()\r\n    {\r\n        return ((100*((movedY - centerY)/maxMoveStick))*-1).toFixed();\r\n    };\r\n\r\n    /**\r\n     * @desc Get the direction of the cursor as a string that indicates the cardinal points where this is oriented\r\n     * @return String of cardinal point N, NE, E, SE, S, SW, W, NW and C when it is placed in the center\r\n     */\r\n    this.GetDir = function()\r\n    {\r\n        return getCardinalDirection();\r\n    };\r\n});\r\n\r\n\r\nvar moveDirection = { left: 0, right: 0, forward: 0, back: 0 }\r\n\r\nvar ground;\r\n\r\nvar player;\r\n\r\nvar clock;\r\n\r\nvar prev_pos;\r\n\r\nvar rotateQuat, walkDir, directionOffset;\r\n\r\nvar delta;\r\n\r\nvar player_collider;\r\n\r\nvar correctedVector;\r\n\r\nvar moveX = 0;\r\nvar moveZ = 0;\r\n\r\nvar dir;\r\nvar forward_vector;\r\n\r\nvar model_ready = false\r\n\r\nvar mouseDown\r\nvar aimDown\r\n\r\nvar camDir;\r\n\r\nvar mov_vector;\r\n\r\nvar model;\r\n\r\nvar scene, renderer, camera, controls;\r\n\r\nvar toggle = false\r\n\r\nvar box;\r\n\r\nwindow.addEventListener(\"load\", function () {\r\n    setTimeout(() => {\r\n        load_model();\r\n\r\n    }, 3000);\r\n})\r\n\r\nvar joy = new JoyStick('joyDiv', {\r\n    // The ID of canvas element\r\n    title: 'joystick',\r\n    // Internal color of Stick\r\n    internalFillColor: '#00AA00',\r\n    // Border width of Stick\r\n    internalLineWidth: 2,\r\n    // Border color of Stick\r\n    internalStrokeColor: '#003300',\r\n    // External reference circonference width\r\n    externalLineWidth: 2,\r\n    //External reference circonference color\r\n    externalStrokeColor: '#008000',\r\n    // Sets the behavior of the stick\r\n    autoReturnToCenter: true\r\n\r\n});\r\n\r\n\r\nfunction load_model() {\r\n    new GLTFLoader().load('scene (7).glb', function (gltf) {\r\n        model = gltf.scene\r\n        console.log(model)\r\n        toggle = true\r\n        wait_models()\r\n    })\r\n}\r\n\r\nfunction wait_models() {\r\n    if (toggle) {\r\n        setupEventHandlers()\r\n\r\n        scene = new THREE.Scene()\r\n\r\n        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);\r\n        camera.updateProjectionMatrix()\r\n        camera.position.y += 7\r\n\r\n\r\n        renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });\r\n        renderer.setSize(window.innerWidth, window.innerHeight);\r\n\r\n        controls = new OrbitControls(camera, renderer.domElement);\r\n\r\n        window.addEventListener('resize', function () {\r\n            camera.aspect = window.innerWidth / window.innerHeight;\r\n            camera.updateProjectionMatrix();\r\n            renderer.setSize(window.innerWidth, window.innerHeight);\r\n        });\r\n\r\n        document.body.appendChild(renderer.domElement);\r\n\r\n        clock = new THREE.Clock()\r\n\r\n        mov_vector = new THREE.Vector3()\r\n\r\n        camDir = new THREE.Vector3()\r\n\r\n\tprev_pos = new THREE.Vector3()\r\n\r\n        var ambientLight = new THREE.AmbientLight(0xffffff, 5);\r\n        scene.add(ambientLight);\r\n        scene.add(model)\r\n\r\n        const geometry = new THREE.BoxGeometry(0.2, 0.2, 0.2);\r\n        const material = new THREE.MeshBasicMaterial({ color: 0x00ff00 });\r\n        box = new THREE.Mesh(geometry, material);\r\n        scene.add(box);\r\n        box.position.y = 7\r\n        //box.position.z = -1\r\n\r\n        update()\r\n    }\r\n}\r\n\r\nvar prev_x = 0;\r\nvar prev_z = 0;\r\n\r\nvar x = 0;\r\nvar z = 0;\r\n\r\nfunction update() {\r\n\r\n    delta = clock.getDelta()\r\n\r\n    camera.getWorldDirection(camDir)\r\n\r\n    //console.log(camDir)\r\n\r\n    moveZ = moveDirection.right - moveDirection.left;\r\n    moveX = moveDirection.forward - moveDirection.back;\r\n\r\n    mov_vector.x = camDir.x / 2.5\r\n    mov_vector.z = camDir.z / 2.5\r\n\r\n    directionOffset = 0\r\n\r\n    if (moveX === 1) {\r\n        if (moveZ === 1) {\r\n            directionOffset = -Math.PI / 4\r\n        } else if (moveZ === -1) {\r\n            directionOffset = Math.PI / 4\r\n        }\r\n    } else if (moveX === -1) {\r\n        if (moveZ === 1) {\r\n            directionOffset = -Math.PI / 4 - Math.PI / 2\r\n        } else if (moveZ === -1) {\r\n            directionOffset = Math.PI / 4 + Math.PI / 2\r\n        } else {\r\n            directionOffset = Math.PI\r\n        }\r\n    } else if (moveZ === 1) {\r\n        directionOffset = -Math.PI / 2\r\n    } else if (moveZ === -1) {\r\n        directionOffset = Math.PI / 2\r\n    }\r\n\r\n    mov_vector.applyAxisAngle(new THREE.Vector3(0, 1, 0), directionOffset)\r\n\r\n    if (moveX !== 0 || moveZ !== 0) {\r\n        camera.position.x += mov_vector.x\r\n        camera.position.z += mov_vector.z\r\n        box.position.x += mov_vector.x\r\n        box.position.z += mov_vector.z\r\n    }\r\n\r\n    controls.target.copy(box.position)\r\n\r\n    x = parseInt(joy.GetX())\r\n    z = parseInt(joy.GetY())\r\n\r\n    if (x >= 75) {\r\n        moveDirection.right = 1\r\n        moveDirection.left = 0\r\n    } else if (x <= -75) {\r\n        moveDirection.right = 0\r\n        moveDirection.left = 1\r\n    } else {\r\n        moveDirection.right = 0\r\n        moveDirection.left = 0\r\n\r\n    }\r\n\r\n    if (z >= 75) {\r\n        moveDirection.forward = 1\r\n        moveDirection.back = 0\r\n    } else if (z <= -75) {\r\n        moveDirection.forward = 0\r\n        moveDirection.back = 1\r\n    } else {\r\n        moveDirection.forward = 0\r\n        moveDirection.back = 0\r\n    }\r\n\r\n    if (isPointInsideBox(camera.position.x, camera.position.z)){\r\nprev_x = camera.position.x\r\nprev_z = camera.position.z\r\nprev_pos.x = box.position.x\r\nprev_pos.z = box.position.z\r\n\t} else {\r\n\tcamera.position.x = prev_x\r\n\tcamera.position.z = prev_z\r\n\tbox.position.x = prev_pos.x\r\n\tbox.position.z = prev_pos.z\r\n}\r\n\r\n    controls.update()\r\n    renderer.render(scene, camera);\r\n\r\n    requestAnimationFrame(update)\r\n}\r\n\r\nfunction isPointInsideBox(x, z) {\r\n    // Check if x and z are within the bounding box\r\n    const minX = Math.min(-76.21540612288777, -75.9593510912879, 202.57380081700836, 203.17769907829856);\r\n    const maxX = Math.max(-76.21540612288777, -75.9593510912879, 202.57380081700836, 203.17769907829856);\r\n    const minZ = Math.min(-8.791333228457304, 26.63528778585343, 26.531239999910195, -8.855059994891958);\r\n    const maxZ = Math.max(-8.791333228457304, 26.63528778585343, 26.531239999910195, -8.855059994891958);\r\n\r\n    if (x < minX || x > maxX || z < minZ || z > maxZ) {\r\n        // Point is outside the bounding box\r\n        return false;\r\n    }\r\n\r\n    // If x and z are within the bounding box, check if the point is inside the convex hull of the vertices\r\n    const insideConvexHull = isPointInsideConvexHull(x, z);\r\n\r\n    return insideConvexHull;\r\n}\r\n\r\n// Helper function to check if a point is inside the convex hull of the box vertices\r\nfunction isPointInsideConvexHull(x, z) {\r\n    // Implement your convex hull check algorithm here.\r\n    // This could be done using techniques like the winding number algorithm.\r\n    // For simplicity, let's assume the vertices form a convex quadrilateral.\r\n    // You may need to replace this part with a more robust algorithm for complex polygons.\r\n\r\n    // In this example, we assume the vertices are in counter-clockwise order.\r\n    const AB = (-75.9593510912879 - -76.21540612288777) * (z - -8.791333228457304) - (x - -76.21540612288777) * (26.63528778585343 - -8.791333228457304);\r\n    const BC = (202.57380081700836 - -75.9593510912879) * (z - 26.63528778585343) - (x - -75.9593510912879) * (26.531239999910195 - 26.63528778585343);\r\n    const CD = (203.17769907829856 - 202.57380081700836) * (z - 26.531239999910195) - (x - 202.57380081700836) * (-8.855059994891958 - 26.531239999910195);\r\n    const DA = (-76.21540612288777 - 203.17769907829856) * (z - -8.855059994891958) - (x - 203.17769907829856) * (-8.791333228457304 - -8.855059994891958);\r\n\r\n    return (AB >= 0 && BC >= 0 && CD >= 0 && DA >= 0) || (AB <= 0 && BC <= 0 && CD <= 0 && DA <= 0);\r\n}\r\n\r\nfunction handleKeyDown(event) {\r\n\r\n    let keyCode = event.keyCode;\r\n\r\n    //console.log(keyCode)\r\n\r\n\r\n    switch (keyCode) {\r\n        case 87: //W: FORWARD\r\n            moveDirection.forward = 1\r\n            break;\r\n\r\n        case 83: //S: BACK\r\n            moveDirection.back = 1\r\n            break;\r\n\r\n        case 65: //A: LEFT\r\n            moveDirection.left = 1\r\n            break;\r\n\r\n        case 68: //D: RIGHT\r\n            moveDirection.right = 1\r\n            break;\r\n    }\r\n\r\n}\r\n\r\nfunction handleKeyUp(event) {\r\n\r\n    let keyCode = event.keyCode;\r\n\r\n    switch (keyCode) {\r\n        case 87: //FORWARD\r\n            moveDirection.forward = 0\r\n            break;\r\n\r\n        case 83: //BACK\r\n            moveDirection.back = 0\r\n            break;\r\n\r\n        case 65: //LEFT\r\n            moveDirection.left = 0\r\n            break;\r\n\r\n        case 68: //RIGHT\r\n            moveDirection.right = 0\r\n            break;\r\n\r\n    }\r\n\r\n}\r\n\r\n\r\nfunction windowResized() {\r\n    resizeCanvas3D(windowWidth, windowHeight);\r\n}\r\n\r\nfunction setupEventHandlers() {\r\n    window.addEventListener('keydown', handleKeyDown, false);\r\n    window.addEventListener('keyup', handleKeyUp, false);\r\n}"],"names":["StickStatus","xPosition","yPosition","x","y","cardinalDirection","clock","prev_pos","directionOffset","camDir","mov_vector","model","scene","renderer","camera","controls","box","moveDirection","left","right","forward","back","moveX","moveZ","toggle","window","addEventListener","setTimeout","GLTFLoader","load","gltf","console","log","wait_models","handleKeyDown","handleKeyUp","THREE","Scene","PerspectiveCamera","innerWidth","innerHeight","updateProjectionMatrix","position","WebGLRenderer","antialias","alpha","setSize","OrbitControls","domElement","aspect","document","body","appendChild","Clock","Vector3","ambientLight","AmbientLight","add","geometry","BoxGeometry","material","MeshBasicMaterial","color","Mesh","update","z","getDelta","getWorldDirection","Math","PI","applyAxisAngle","target","copy","parseInt","joy","GetX","GetY","isPointInsideConvexHull","AB","BC","CD","DA","prev_x","prev_z","render","requestAnimationFrame","container","parameters","callback","title","width","height","internalFillColor","internalLineWidth","internalStrokeColor","externalLineWidth","externalStrokeColor","autoReturnToCenter","objContainer","getElementById","style","touchAction","canvas","createElement","id","clientWidth","clientHeight","context","getContext","pressed","circumference","internalRadius","maxMoveStick","externalRadius","centerX","centerY","directionHorizontalLimitPos","directionHorizontalLimitNeg","directionVerticalLimitPos","directionVerticalLimitNeg","movedX","movedY","drawExternal","beginPath","arc","lineWidth","strokeStyle","stroke","drawInternal","grd","createRadialGradient","addColorStop","fillStyle","fill","getCardinalDirection","result","orizontal","vertical","documentElement","event","targetTouches","pageX","pageY","offsetParent","tagName","toUpperCase","offsetLeft","offsetTop","clearRect","toFixed","GetWidth","GetHeight","GetPosX","GetPosY","GetDir","keyCode"],"version":3,"file":"index.1a49ce9c.js.map"}