{"mappings":"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","sources":["<anon>","src/sketch.js"],"sourcesContent":["var moveDirection = {\n    left: 0,\n    right: 0,\n    forward: 0,\n    back: 0\n};\nvar ground;\nvar player;\nvar clock;\nvar rotateQuat, walkDir, directionOffset;\nvar delta;\nvar player_collider;\nvar correctedVector;\nvar moveX = 0;\nvar moveZ = 0;\nvar dir;\nvar forward_vector;\nvar model_ready = false;\nvar mouseDown;\nvar aimDown;\nvar camDir;\nvar mov_vector;\nvar model;\nvar scene, renderer, camera, controls;\nvar toggle = false;\nvar box;\nwindow.addEventListener(\"load\", function() {\n    setTimeout(()=>{\n        load_model();\n    }, 3000);\n});\nvar joy = new JoyStick(\"joyDiv\", {\n    // The ID of canvas element\n    title: \"joystick\",\n    // Internal color of Stick\n    internalFillColor: \"#00AA00\",\n    // Border width of Stick\n    internalLineWidth: 2,\n    // Border color of Stick\n    internalStrokeColor: \"#003300\",\n    // External reference circonference width\n    externalLineWidth: 2,\n    //External reference circonference color\n    externalStrokeColor: \"#008000\",\n    // Sets the behavior of the stick\n    autoReturnToCenter: true\n});\nfunction load_model() {\n    new GLTFLoader().load(\"scene (7).glb\", function(gltf) {\n        model = gltf.scene;\n        console.log(model);\n        toggle = true;\n        wait_models();\n    });\n}\nfunction wait_models() {\n    if (toggle) {\n        setupEventHandlers();\n        scene = new THREE.Scene();\n        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);\n        camera.updateProjectionMatrix();\n        camera.position.y += 7;\n        renderer = new THREE.WebGLRenderer({\n            antialias: true,\n            alpha: true\n        });\n        renderer.setSize(window.innerWidth, window.innerHeight);\n        controls = new OrbitControls(camera, renderer.domElement);\n        window.addEventListener(\"resize\", function() {\n            camera.aspect = window.innerWidth / window.innerHeight;\n            camera.updateProjectionMatrix();\n            renderer.setSize(window.innerWidth, window.innerHeight);\n        });\n        document.body.appendChild(renderer.domElement);\n        clock = new THREE.Clock();\n        mov_vector = new THREE.Vector3();\n        camDir = new THREE.Vector3();\n        var ambientLight = new THREE.AmbientLight(0xffffff, 5);\n        scene.add(ambientLight);\n        scene.add(model);\n        const geometry = new THREE.BoxGeometry(0.2, 0.2, 0.2);\n        const material = new THREE.MeshBasicMaterial({\n            color: 0x00ff00\n        });\n        box = new THREE.Mesh(geometry, material);\n        scene.add(box);\n        box.position.y = 7;\n        //box.position.z = -1\n        update();\n    }\n}\nvar prev_x = 0;\nvar prev_z = 0;\nvar x = 0;\nvar z = 0;\nfunction update() {\n    delta = clock.getDelta();\n    camera.getWorldDirection(camDir);\n    //console.log(camDir)\n    moveZ = moveDirection.right - moveDirection.left;\n    moveX = moveDirection.forward - moveDirection.back;\n    mov_vector.x = camDir.x / 2.5;\n    mov_vector.z = camDir.z / 2.5;\n    directionOffset = 0;\n    if (moveX === 1) {\n        if (moveZ === 1) directionOffset = -Math.PI / 4;\n        else if (moveZ === -1) directionOffset = Math.PI / 4;\n    } else if (moveX === -1) {\n        if (moveZ === 1) directionOffset = -Math.PI / 4 - Math.PI / 2;\n        else if (moveZ === -1) directionOffset = Math.PI / 4 + Math.PI / 2;\n        else directionOffset = Math.PI;\n    } else if (moveZ === 1) directionOffset = -Math.PI / 2;\n    else if (moveZ === -1) directionOffset = Math.PI / 2;\n    mov_vector.applyAxisAngle(new THREE.Vector3(0, 1, 0), directionOffset);\n    if (moveX !== 0 || moveZ !== 0) {\n        camera.position.x += mov_vector.x;\n        camera.position.z += mov_vector.z;\n        box.position.x += mov_vector.x;\n        box.position.z += mov_vector.z;\n    }\n    controls.target.copy(box.position);\n    x = parseInt(joy.GetX());\n    z = parseInt(joy.GetY());\n    if (x >= 75) {\n        moveDirection.right = 1;\n        moveDirection.left = 0;\n    } else if (x <= -75) {\n        moveDirection.right = 0;\n        moveDirection.left = 1;\n    } else {\n        moveDirection.right = 0;\n        moveDirection.left = 0;\n    }\n    if (z >= 75) {\n        moveDirection.forward = 1;\n        moveDirection.back = 0;\n    } else if (z <= -75) {\n        moveDirection.forward = 0;\n        moveDirection.back = 1;\n    } else {\n        moveDirection.forward = 0;\n        moveDirection.back = 0;\n    }\n    //console.log(isPointInsideBox(camera.position.x, camera.position.z))\n    controls.update();\n    renderer.render(scene, camera);\n    requestAnimationFrame(update);\n}\nfunction isPointInsideBox(x, z) {\n    // Check if x and z are within the bounding box\n    const minX = Math.min(-76.21540612288777, -75.9593510912879, 202.57380081700836, 203.17769907829856);\n    const maxX = Math.max(-76.21540612288777, -75.9593510912879, 202.57380081700836, 203.17769907829856);\n    const minZ = Math.min(-8.791333228457304, 26.63528778585343, 26.531239999910195, -8.855059994891958);\n    const maxZ = Math.max(-8.791333228457304, 26.63528778585343, 26.531239999910195, -8.855059994891958);\n    if (x < minX || x > maxX || z < minZ || z > maxZ) // Point is outside the bounding box\n    return false;\n    // If x and z are within the bounding box, check if the point is inside the convex hull of the vertices\n    const insideConvexHull = isPointInsideConvexHull(x, z);\n    return insideConvexHull;\n}\n// Helper function to check if a point is inside the convex hull of the box vertices\nfunction isPointInsideConvexHull(x, z) {\n    // Implement your convex hull check algorithm here.\n    // This could be done using techniques like the winding number algorithm.\n    // For simplicity, let's assume the vertices form a convex quadrilateral.\n    // You may need to replace this part with a more robust algorithm for complex polygons.\n    // In this example, we assume the vertices are in counter-clockwise order.\n    const AB = 0.2560550315998711 * (z - -8.791333228457304) - (x - -76.21540612288777) * 35.42662101431073;\n    const BC = 278.53315190829625 * (z - 26.63528778585343) - (x - -75.9593510912879) * -0.1040477859432336;\n    const CD = 0.6038982612901975 * (z - 26.531239999910195) - (x - 202.57380081700836) * -35.38629999480215;\n    const DA = -279.39310520118636 * (z - -8.855059994891958) - (x - 203.17769907829856) * 0.06372676643465347;\n    return AB >= 0 && BC >= 0 && CD >= 0 && DA >= 0 || AB <= 0 && BC <= 0 && CD <= 0 && DA <= 0;\n}\nfunction handleKeyDown(event) {\n    let keyCode = event.keyCode;\n    //console.log(keyCode)\n    switch(keyCode){\n        case 87:\n            moveDirection.forward = 1;\n            break;\n        case 83:\n            moveDirection.back = 1;\n            break;\n        case 65:\n            moveDirection.left = 1;\n            break;\n        case 68:\n            moveDirection.right = 1;\n            break;\n    }\n}\nfunction handleKeyUp(event) {\n    let keyCode = event.keyCode;\n    switch(keyCode){\n        case 87:\n            moveDirection.forward = 0;\n            break;\n        case 83:\n            moveDirection.back = 0;\n            break;\n        case 65:\n            moveDirection.left = 0;\n            break;\n        case 68:\n            moveDirection.right = 0;\n            break;\n    }\n}\nfunction windowResized() {\n    resizeCanvas3D(windowWidth, windowHeight);\n}\nfunction setupEventHandlers() {\n    window.addEventListener(\"keydown\", handleKeyDown, false);\n    window.addEventListener(\"keyup\", handleKeyUp, false);\n}\n\n//# sourceMappingURL=index.ffd9e6d1.js.map\n","var moveDirection = { left: 0, right: 0, forward: 0, back: 0 }\r\n\r\nvar ground;\r\n\r\nvar player;\r\n\r\nvar clock;\r\n\r\nvar rotateQuat, walkDir, directionOffset;\r\n\r\nvar delta;\r\n\r\nvar player_collider;\r\n\r\nvar correctedVector;\r\n\r\nvar moveX = 0;\r\nvar moveZ = 0;\r\n\r\nvar dir;\r\nvar forward_vector;\r\n\r\nvar model_ready = false\r\n\r\nvar mouseDown\r\nvar aimDown\r\n\r\nvar camDir;\r\n\r\nvar mov_vector;\r\n\r\nvar model;\r\n\r\nvar scene, renderer, camera, controls;\r\n\r\nvar toggle = false\r\n\r\nvar box;\r\n\r\nwindow.addEventListener(\"load\", function () {\r\n    setTimeout(() => {\r\n        load_model();\r\n\r\n    }, 3000);\r\n})\r\n\r\nvar joy = new JoyStick('joyDiv', {\r\n    // The ID of canvas element\r\n    title: 'joystick',\r\n    // Internal color of Stick\r\n    internalFillColor: '#00AA00',\r\n    // Border width of Stick\r\n    internalLineWidth: 2,\r\n    // Border color of Stick\r\n    internalStrokeColor: '#003300',\r\n    // External reference circonference width\r\n    externalLineWidth: 2,\r\n    //External reference circonference color\r\n    externalStrokeColor: '#008000',\r\n    // Sets the behavior of the stick\r\n    autoReturnToCenter: true\r\n\r\n});\r\n\r\n\r\nfunction load_model() {\r\n    new GLTFLoader().load('scene (7).glb', function (gltf) {\r\n        model = gltf.scene\r\n        console.log(model)\r\n        toggle = true\r\n        wait_models()\r\n    })\r\n}\r\n\r\nfunction wait_models() {\r\n    if (toggle) {\r\n        setupEventHandlers()\r\n\r\n        scene = new THREE.Scene()\r\n\r\n        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);\r\n        camera.updateProjectionMatrix()\r\n        camera.position.y += 7\r\n\r\n\r\n        renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });\r\n        renderer.setSize(window.innerWidth, window.innerHeight);\r\n\r\n        controls = new OrbitControls(camera, renderer.domElement);\r\n\r\n        window.addEventListener('resize', function () {\r\n            camera.aspect = window.innerWidth / window.innerHeight;\r\n            camera.updateProjectionMatrix();\r\n            renderer.setSize(window.innerWidth, window.innerHeight);\r\n        });\r\n\r\n        document.body.appendChild(renderer.domElement);\r\n\r\n        clock = new THREE.Clock()\r\n\r\n        mov_vector = new THREE.Vector3()\r\n\r\n        camDir = new THREE.Vector3()\r\n\r\n        var ambientLight = new THREE.AmbientLight(0xffffff, 5);\r\n        scene.add(ambientLight);\r\n        scene.add(model)\r\n\r\n        const geometry = new THREE.BoxGeometry(0.2, 0.2, 0.2);\r\n        const material = new THREE.MeshBasicMaterial({ color: 0x00ff00 });\r\n        box = new THREE.Mesh(geometry, material);\r\n        scene.add(box);\r\n        box.position.y = 7\r\n        //box.position.z = -1\r\n\r\n        update()\r\n    }\r\n}\r\n\r\nvar prev_x = 0;\r\nvar prev_z = 0;\r\n\r\nvar x = 0;\r\nvar z = 0;\r\n\r\nfunction update() {\r\n\r\n    delta = clock.getDelta()\r\n\r\n    camera.getWorldDirection(camDir)\r\n\r\n    //console.log(camDir)\r\n\r\n    moveZ = moveDirection.right - moveDirection.left;\r\n    moveX = moveDirection.forward - moveDirection.back;\r\n\r\n    mov_vector.x = camDir.x / 2.5\r\n    mov_vector.z = camDir.z / 2.5\r\n\r\n    directionOffset = 0\r\n\r\n    if (moveX === 1) {\r\n        if (moveZ === 1) {\r\n            directionOffset = -Math.PI / 4\r\n        } else if (moveZ === -1) {\r\n            directionOffset = Math.PI / 4\r\n        }\r\n    } else if (moveX === -1) {\r\n        if (moveZ === 1) {\r\n            directionOffset = -Math.PI / 4 - Math.PI / 2\r\n        } else if (moveZ === -1) {\r\n            directionOffset = Math.PI / 4 + Math.PI / 2\r\n        } else {\r\n            directionOffset = Math.PI\r\n        }\r\n    } else if (moveZ === 1) {\r\n        directionOffset = -Math.PI / 2\r\n    } else if (moveZ === -1) {\r\n        directionOffset = Math.PI / 2\r\n    }\r\n\r\n    mov_vector.applyAxisAngle(new THREE.Vector3(0, 1, 0), directionOffset)\r\n\r\n    if (moveX !== 0 || moveZ !== 0) {\r\n        camera.position.x += mov_vector.x\r\n        camera.position.z += mov_vector.z\r\n        box.position.x += mov_vector.x\r\n        box.position.z += mov_vector.z\r\n    }\r\n\r\n    controls.target.copy(box.position)\r\n\r\n    x = parseInt(joy.GetX())\r\n    z = parseInt(joy.GetY())\r\n\r\n    if (x >= 75) {\r\n        moveDirection.right = 1\r\n        moveDirection.left = 0\r\n    } else if (x <= -75) {\r\n        moveDirection.right = 0\r\n        moveDirection.left = 1\r\n    } else {\r\n        moveDirection.right = 0\r\n        moveDirection.left = 0\r\n\r\n    }\r\n\r\n    if (z >= 75) {\r\n        moveDirection.forward = 1\r\n        moveDirection.back = 0\r\n    } else if (z <= -75) {\r\n        moveDirection.forward = 0\r\n        moveDirection.back = 1\r\n    } else {\r\n        moveDirection.forward = 0\r\n        moveDirection.back = 0\r\n    }\r\n\r\n    //console.log(isPointInsideBox(camera.position.x, camera.position.z))\r\n\r\n    controls.update()\r\n    renderer.render(scene, camera);\r\n\r\n    requestAnimationFrame(update)\r\n}\r\n\r\nfunction isPointInsideBox(x, z) {\r\n    // Check if x and z are within the bounding box\r\n    const minX = Math.min(-76.21540612288777, -75.9593510912879, 202.57380081700836, 203.17769907829856);\r\n    const maxX = Math.max(-76.21540612288777, -75.9593510912879, 202.57380081700836, 203.17769907829856);\r\n    const minZ = Math.min(-8.791333228457304, 26.63528778585343, 26.531239999910195, -8.855059994891958);\r\n    const maxZ = Math.max(-8.791333228457304, 26.63528778585343, 26.531239999910195, -8.855059994891958);\r\n\r\n    if (x < minX || x > maxX || z < minZ || z > maxZ) {\r\n        // Point is outside the bounding box\r\n        return false;\r\n    }\r\n\r\n    // If x and z are within the bounding box, check if the point is inside the convex hull of the vertices\r\n    const insideConvexHull = isPointInsideConvexHull(x, z);\r\n\r\n    return insideConvexHull;\r\n}\r\n\r\n// Helper function to check if a point is inside the convex hull of the box vertices\r\nfunction isPointInsideConvexHull(x, z) {\r\n    // Implement your convex hull check algorithm here.\r\n    // This could be done using techniques like the winding number algorithm.\r\n    // For simplicity, let's assume the vertices form a convex quadrilateral.\r\n    // You may need to replace this part with a more robust algorithm for complex polygons.\r\n\r\n    // In this example, we assume the vertices are in counter-clockwise order.\r\n    const AB = (-75.9593510912879 - -76.21540612288777) * (z - -8.791333228457304) - (x - -76.21540612288777) * (26.63528778585343 - -8.791333228457304);\r\n    const BC = (202.57380081700836 - -75.9593510912879) * (z - 26.63528778585343) - (x - -75.9593510912879) * (26.531239999910195 - 26.63528778585343);\r\n    const CD = (203.17769907829856 - 202.57380081700836) * (z - 26.531239999910195) - (x - 202.57380081700836) * (-8.855059994891958 - 26.531239999910195);\r\n    const DA = (-76.21540612288777 - 203.17769907829856) * (z - -8.855059994891958) - (x - 203.17769907829856) * (-8.791333228457304 - -8.855059994891958);\r\n\r\n    return (AB >= 0 && BC >= 0 && CD >= 0 && DA >= 0) || (AB <= 0 && BC <= 0 && CD <= 0 && DA <= 0);\r\n}\r\n\r\nfunction handleKeyDown(event) {\r\n\r\n    let keyCode = event.keyCode;\r\n\r\n    //console.log(keyCode)\r\n\r\n\r\n    switch (keyCode) {\r\n        case 87: //W: FORWARD\r\n            moveDirection.forward = 1\r\n            break;\r\n\r\n        case 83: //S: BACK\r\n            moveDirection.back = 1\r\n            break;\r\n\r\n        case 65: //A: LEFT\r\n            moveDirection.left = 1\r\n            break;\r\n\r\n        case 68: //D: RIGHT\r\n            moveDirection.right = 1\r\n            break;\r\n    }\r\n\r\n}\r\n\r\nfunction handleKeyUp(event) {\r\n\r\n    let keyCode = event.keyCode;\r\n\r\n    switch (keyCode) {\r\n        case 87: //FORWARD\r\n            moveDirection.forward = 0\r\n            break;\r\n\r\n        case 83: //BACK\r\n            moveDirection.back = 0\r\n            break;\r\n\r\n        case 65: //LEFT\r\n            moveDirection.left = 0\r\n            break;\r\n\r\n        case 68: //RIGHT\r\n            moveDirection.right = 0\r\n            break;\r\n\r\n    }\r\n\r\n}\r\n\r\n\r\nfunction windowResized() {\r\n    resizeCanvas3D(windowWidth, windowHeight);\r\n}\r\n\r\nfunction setupEventHandlers() {\r\n    window.addEventListener('keydown', handleKeyDown, false);\r\n    window.addEventListener('keyup', handleKeyUp, false);\r\n}"],"names":["clock","directionOffset","camDir","mov_vector","model","scene","renderer","camera","controls","box","moveDirection","left","right","forward","back","moveX","moveZ","toggle","window","addEventListener","setTimeout","GLTFLoader","load","gltf","console","log","wait_models","handleKeyDown","handleKeyUp","THREE","Scene","PerspectiveCamera","innerWidth","innerHeight","updateProjectionMatrix","position","y","WebGLRenderer","antialias","alpha","setSize","OrbitControls","domElement","aspect","document","body","appendChild","Clock","Vector3","ambientLight","AmbientLight","add","geometry","BoxGeometry","material","MeshBasicMaterial","color","Mesh","update","getDelta","getWorldDirection","x","z","Math","PI","applyAxisAngle","target","copy","parseInt","joy","GetX","GetY","render","requestAnimationFrame","JoyStick","title","internalFillColor","internalLineWidth","internalStrokeColor","externalLineWidth","externalStrokeColor","autoReturnToCenter","event","keyCode"],"version":3,"file":"index.ffd9e6d1.js.map"}